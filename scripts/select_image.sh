#!/usr/bin/env bash
# -----------------------------------------------------------------------------
# select_image.sh - Interactive CLI picker for screenshots with Markdown insert
# -----------------------------------------------------------------------------
# This tool lists video screenshots alongside their time-range summary, shows a
# live thumbnail preview in the terminal, and upon selection copies (and
# optionally appends) the Markdown image syntax for the chosen file.
#
# Priority of preview back-ends (auto-detected):
#   1) imgcat (iTerm2 official)
#   2) timg
#   3) viu
#   4) chafa (ANSI fallback)
#
# Dependencies (checked at runtime):
#   • bash ≥ 4, fzf, awk, sed, grep
#   • At least ONE of: imgcat, timg, viu, chafa
#   • For clipboard support: pbcopy (mac) or xclip/xsel (Linux) – optional
#
# Usage:
#   select_image.sh -s summary.txt -r screenshots_dir [-n note.md]
#
#   -s, --summary   File produced by pre_srt_summary.sh ("start-end|summary")
#   -r, --root      Root directory that contains <time_range> sub-folders
#   -n, --note      If provided, append generated Markdown to this file.
#   --width/--height Override preview size (default 80x40)
#
# The script is fail-fast (set -eEuo pipefail) and logs errors via common.sh
# if available. It never mutates or deletes media files.
# -----------------------------------------------------------------------------

set -eEuo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Source common helpers if present
if [[ -f "$SCRIPT_DIR/common.sh" ]]; then
  # shellcheck source=common.sh
  source "$SCRIPT_DIR/common.sh"
else
  # Lightweight replacements in case common.sh is unavailable
  info()  { printf '[INFO]  %s\n' "$*" >&2; }
  warn()  { printf '[WARN]  %s\n' "$*" >&2; }
  error() { printf '[ERROR] %s\n' "$*" >&2; exit 1; }
fi

###############################################################################
# Argument parsing                                                            #
###############################################################################
SUMMARY_FILE=""
IMG_ROOT=""
NOTE_FILE=""
PREVIEW_WIDTH=80
PREVIEW_HEIGHT=40

print_usage() {
  cat >&2 <<EOF
Usage: ${0##*/} -s summary.txt -r screenshots_dir [options]

Options:
  -s|--summary FILE    Summary file generated by pre_srt_summary.sh (required)
  -r|--root DIR        Root folder that contains <time_range>/image.jpg (req.)
  -n|--note FILE       Append Markdown syntax to FILE instead of clipboard
  --width  N          Preview width  (default: $PREVIEW_WIDTH)
  --height N          Preview height (default: $PREVIEW_HEIGHT)
  -h|--help           Show this help
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    -s|--summary)  SUMMARY_FILE="$2"; shift 2;;
    -r|--root)     IMG_ROOT="$2";    shift 2;;
    -n|--note)     NOTE_FILE="$2";   shift 2;;
    --width)       PREVIEW_WIDTH="$2"; shift 2;;
    --height)      PREVIEW_HEIGHT="$2"; shift 2;;
    -h|--help)     print_usage; exit 0;;
    *)             error "Unknown option: $1";;
  esac
done

[[ -f "$SUMMARY_FILE" ]] || error "Missing summary file: $SUMMARY_FILE"
[[ -d "$IMG_ROOT"    ]] || error "Missing screenshots root dir: $IMG_ROOT"

###############################################################################
# Dependency checks                                                           #
###############################################################################
command -v fzf >/dev/null 2>&1 || error "fzf not found. Install via: brew install fzf"
command -v awk >/dev/null 2>&1 || error "awk not found"

# Clipboard tool detection (optional)
CLIP_CMD=""
if command -v pbcopy >/dev/null 2>&1; then
  CLIP_CMD="pbcopy"
elif command -v xclip >/dev/null 2>&1; then
  CLIP_CMD="xclip -selection clipboard"
elif command -v xsel >/dev/null 2>&1; then
  CLIP_CMD="xsel -ib"
fi

###############################################################################
# Preview back-end detection                                                  #
###############################################################################
detect_preview_cmd() {
  local cmd="";
  # iTerm2 official imgcat
  if [[ "${TERM_PROGRAM:-}" == "iTerm.app" ]] && command -v imgcat >/dev/null 2>&1; then
    cmd=(imgcat --height "$PREVIEW_HEIGHT")
  elif command -v timg >/dev/null 2>&1; then
    cmd=(timg --width "$PREVIEW_WIDTH" --height "$PREVIEW_HEIGHT")
  elif command -v viu >/dev/null 2>&1; then
    cmd=(viu -w "$PREVIEW_WIDTH" -h "$PREVIEW_HEIGHT" --quiet)
  elif command -v chafa >/dev/null 2>&1; then
    cmd=(chafa -s "${PREVIEW_WIDTH}x${PREVIEW_HEIGHT}")
  else
    error "No supported image preview tool found (imgcat/timg/viu/chafa)"
  fi
  printf '%q ' "${cmd[@]}"
}
PREVIEW_CMD="$(detect_preview_cmd)"
info "Using preview command: $PREVIEW_CMD"

###############################################################################
# Helper: generate list for fzf                                               #
###############################################################################
# Output format:  <time>|<summary>|<img_path>
# We use | as delimiter and rely on summary not containing it (generated text).  

generate_list() {
  local range summary img ext
  while IFS='|' read -r range summary; do
    # Trim spaces
    range="${range//[[:space:]]/}"
    summary="${summary## }"
    summary="${summary%% }"
    # Accept jpg/jpeg/png
    for ext in jpg jpeg png; do
      for img in "$IMG_ROOT/$range"/*."$ext"; do
        [[ -e "$img" ]] || continue
        printf '%s | %s | %s\n' "$range" "$summary" "$img"
      done
    done
  done < "$SUMMARY_FILE"
}

###############################################################################
# Helper: convert absolute to relative path                                   #
###############################################################################
relpath() {
  # If realpath supports --relative-to (GNU), use that. Else fallback to python.
  local target="$1"
  if realpath --relative-to=. "$target" >/dev/null 2>&1; then
    realpath --relative-to=. "$target"
  else
    # Works on macOS (BSD realpath lacks --relative-to)
    python - <<PY "$PWD" "$target"
import os,sys
print(os.path.relpath(sys.argv[2], sys.argv[1]))
PY
  fi
}

###############################################################################
# Main: launch fzf                                                            #
###############################################################################
selected=$(generate_list | \
  fzf --ansi --delimiter '|' --with-nth 1,2 \
      --preview "bash -c '$PREVIEW_CMD \"$(echo {} | cut -d\"|\" -f3 | xargs)\"'" \
      --preview-window=right:60%:border-left)

[[ -z "${selected:-}" ]] && {
  info "No selection made. Exiting."; exit 0; }

img_path=$(printf '%s' "$selected" | cut -d'|' -f3 | xargs)
# Sanity check
[[ -f "$img_path" ]] || error "Selected file does not exist: $img_path"

relative_path=$(relpath "$img_path")
markdown="![]($relative_path)"

if [[ -n "$NOTE_FILE" ]]; then
  printf '%s\n' "$markdown" >> "$NOTE_FILE"
  info "Appended to $NOTE_FILE: $markdown"
fi

if [[ -n "$CLIP_CMD" ]]; then
  printf '%s' "$markdown" | eval "$CLIP_CMD"
  info "Copied Markdown to clipboard."
else
  printf '%s\n' "$markdown"
fi

info "Done."
