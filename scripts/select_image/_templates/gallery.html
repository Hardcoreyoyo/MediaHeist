
<!DOCTYPE html>
    <html lang="en">
        
        <head>
        
        <meta charset="utf-8" />

        <title>Image Selector</title>

        <style>
            body { font-family: sans-serif; margin: 0; padding:0; }
            h2 { margin-top: 0; }
            .container { display: flex; height: 100vh; gap:1rem; }
            #fileList { width: 40%; overflow-y: auto; border-right:1px solid #ccc; padding: 1rem; }
            #infoPane { width: 30%; overflow-y: auto; padding: 1rem; background:#f9f9f9; border-right:1px solid #ccc; font-size:0.9em; }
            #infoPane .segment-block { margin-bottom:1.25rem; padding:0.5rem; border:1px solid #ddd; background:#fff; }
            #infoPane .segment-block .timestamp { font-weight:bold; display:block; margin-bottom:4px; color:#333;}
            #infoPane .segment-block .text { white-space: pre-wrap; font-family:monospace; }
            .preview-wrapper { flex:1; padding: 1rem; overflow-y:auto; }
            .preview-wrapper img { max-width: 100%; border: 1px solid #ddd; display:block;}
            ul { list-style:none; padding-left:0; }
            li { padding:4px 8px; margin-bottom:2px; border-radius:4px; cursor:pointer; }
            li:hover { background:#efefef; }
            #fileList li[data-file].selected { background:#007acc; color:#fff; }
            .segment-header { cursor: pointer; font-weight: bold; color: #333; background-color: #f5f5f5; padding: 6px 8px; margin: 4px 0; border-left: 3px solid #007acc; font-size: 0.9em;}
            .segment-header.active { background-color: #e6f3ff; border-left-color: #0056b3; }
            .segment-images { margin-left: 8px; }
            .segment-images li { padding-left: 8px; border-left: 1px solid #e0e0e0; }
            .selected { background-color: #d0e0ff; }
            .confirmed { background-color: #cccccc; }
            #toast { position: fixed; right: 1rem; bottom: 1rem; background-color:#333; color:#fff; padding:8px 12px; border-radius:4px; opacity:0; transition: opacity .3s; pointer-events:none; }
            #toast.show { opacity:1; }
            #preview { flex: 1; display: flex; justify-content: center; align-items: flex-start; padding: 1rem; }
            #preview img { height: auto; width: auto; max-width: 100%; max-height: 100%; }
            .segment { margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #e0e0e0; }
            .seg-title { font-weight: bold; color: #333; margin-bottom: 0.25rem; }
            .seg-images { display:flex; flex-wrap:wrap; gap:4px; margin-top:4px; }
            .seg-images img { max-width:100px; height:auto; border:1px solid #ccc; }
            .current-seg { background-color:#fffbe6; }
            /* Export modal styles */
            #exportModalOverlay { position:fixed; inset:0; background:rgba(0,0,0,0.55); display:none; justify-content:center; align-items:center; z-index:9999; }
            #exportModal { background:#fff; padding:24px; border-radius:8px; max-width:480px; width:90%; box-shadow:0 4px 20px rgba(0,0,0,.3); font-size:14px; }
            #exportModal h3 { margin-top:0; }
            #exportModalActions { margin-top:16px; display:flex; gap:12px; justify-content:flex-end; }
            #exportModalActions button { padding:6px 12px; cursor:pointer; }
        </style>
        </head>

        <body>
            <h2 style="margin:0; padding:1rem;">Select an image</h2>
            <div class="container">
            <div id="fileList">
                {% if grouped_images and segments %}
                    <!-- Grouped by segments -->
                    {% for i, segment in enumerate(segments) %}
                        {% set segment_images = grouped_images.get('segment_' ~ i, []) %}
                        {% if segment_images %}
                        <div class="segment-group">
                            <div class="segment-header" data-segment="{{ i }}">
                                <span>{{ segment.start }} - {{ segment.end }}</span>
                                <span style="font-weight:normal; font-size:0.8em; color:#666; margin-left:4px;">({{ segment_images|length }} images)</span>
                            </div>
                            <ul class="segment-images">
                                {% for img in segment_images %}
                                <li data-file="{{ img }}" data-segment="{{ i }}">{{ img }}</li>
                                {% endfor %}
                            </ul>
                        </div>
                        {% endif %}
                    {% endfor %}
                    
                    <!-- Ungrouped images -->
                    {% if grouped_images.get('ungrouped', []) %}
                    <div class="segment-group">
                        <div class="segment-header">其他圖片</div>
                        <ul class="segment-images">
                            {% for img in grouped_images.ungrouped %}
                            <li data-file="{{ img }}" data-segment="-1">{{ img }}</li>
                            {% endfor %}
                        </ul>
                    </div>
                    {% endif %}
                {% else %}
                    <!-- Fallback: show all images without grouping -->
                    <ul>
                    {% for img in images %}
                    <li data-file="{{ img }}" data-segment="-1">{{ img }}</li>
                    {% endfor %}
                    </ul>
                {% endif %}
            </div>
            
            <div id="infoPane">
                <!-- Transcript segments will be loaded lazily -->
            </div>
            
            <div class="preview-wrapper">
            <div id="preview"></div>
            <div id="toast"></div>
            </div>
            </div> <!-- container -->
            
            <script>
            // fetch transcript segments for right pane
            // dynamic load next segment to avoid heavy initial load.
            </script>
            
            <script>
            // --- enhanced navigation and selection ---
            const listItems = Array.from(document.querySelectorAll('#fileList li[data-file]'));
            const segmentHeaders = Array.from(document.querySelectorAll('.segment-header[data-segment]'));

            // toast helper
            function showToast(msg){
            const toast=document.getElementById('toast');
            toast.textContent=msg;
            toast.classList.add('show');
            setTimeout(()=>toast.classList.remove('show'),2000);
            }

            function confirmFile(file, li){
            const segmentIdx = li ? parseInt(li.dataset.segment) : segIdx;
            const actualSegIdx = segmentIdx >= 0 ? segmentIdx : segIdx;
            const selArr = (selections[actualSegIdx] ??= []);
            const wrap = segDivs[actualSegIdx]?.querySelector('.seg-images');
            const idx = selArr.indexOf(file);
            if(idx === -1){
                // add
                postSelection(file);
                selArr.push(file);
                if(li) li.classList.add('confirmed');
                showToast('已添加內容');
            } else {
                // remove
                selArr.splice(idx,1);
                if(li) li.classList.remove('confirmed');
                showToast('已移除內容');
            }
            // refresh segment snippet list
            refreshSnippet(actualSegIdx);
            }

            async function postSelection(file){
            try{
                await fetch('/select',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({filename:file})});
            }catch(e){console.error(e);}
            }

            function showPreview(file){
            const preview=document.getElementById('preview');
            preview.innerHTML='';
            const img=document.createElement('img');
            img.src='/static/'+file;
            img.alt=file;
            preview.appendChild(img);
            }

            let currentIndex=-1;
            function highlight(idx){
            if(idx<0 || idx>=listItems.length)return;
            listItems.forEach(li => li.classList.remove('selected'));
            segmentHeaders.forEach(h => h.classList.remove('active'));
            currentIndex = (idx + listItems.length) % listItems.length;
            const li = listItems[currentIndex];
            li.classList.add('selected');
            li.scrollIntoView({behavior:'auto',block:'nearest'});
            showPreview(li.dataset.file);
            
            // Highlight corresponding segment header
            const segmentIdx = parseInt(li.dataset.segment);
            if (segmentIdx >= 0) {
                const header = segmentHeaders.find(h => parseInt(h.dataset.segment) === segmentIdx);
                if (header) header.classList.add('active');
            }
            }

            // initial highlight first item
            if (listItems.length) {
            highlight(0);
            }

            // click handler override to use highlight and confirm
            listItems.forEach((li, idx) => {
            li.addEventListener('click', () => {
                highlight(idx);
                confirmFile(li.dataset.file, li);
            });
            });

            // keyboard navigation
            window.addEventListener('keydown', (ev) => {
            if (ev.key === 'ArrowDown') {
                ev.preventDefault();
                highlight(currentIndex + 1);
            } else if (ev.key === 'ArrowUp') {
                ev.preventDefault();
                highlight(currentIndex - 1);
            } else if (ev.key === 'Enter') {
                ev.preventDefault();
                const li = listItems[currentIndex];
                if (li) confirmFile(li.dataset.file, li);
            }
            });

            // segment header click toggles highlight & scroll
            segmentHeaders.forEach(header => {
            header.addEventListener('click', () => {
                segmentHeaders.forEach(h => h.classList.remove('active'));
                header.classList.add('active');
                // navigate to first file in that segment
                const segIndex = parseInt(header.dataset.segment);
                const target = listItems.find(li => parseInt(li.dataset.segment) === segIndex);
                if (target) {
                const idx = listItems.indexOf(target);
                highlight(idx);
                }
            });
            });

            // ------- load transcript segments incrementally -------
            let segments = [];
            let segIdx = 0;
            let segDivs = [];
            const selections = {}; // segIdx -> array of filenames
            async function loadSegments() {
                const res = await fetch('/segments');
                if (!res.ok) return;
                segments = await res.json();
                renderNextSegment();
            }
            function setCurrentSegment(idx){
                // update segment highlight
                segDivs.forEach(d=>d.classList.remove('current-seg'));
                if(idx>=0 && idx<segDivs.length){
                    segDivs[idx].classList.add('current-seg');
                    segDivs[idx].scrollIntoView({behavior:'smooth',block:'nearest'});
                }
                // refresh confirmed state on file list
                listItems.forEach(li=>li.classList.remove('confirmed'));
                const selectedFiles = selections[idx] ?? [];
                listItems.forEach(li=>{
                    if(selectedFiles.includes(li.dataset.file)){
                        li.classList.add('confirmed');
                    }
                });
            }
            function renderNextSegment() {
                if (segIdx >= segments.length) return;
                const pane = document.getElementById('infoPane');
                const seg = segments[segIdx];
                const div = document.createElement('div');
                div.className = 'segment-block';
                div.innerHTML = `
                    <div class="timestamp">${seg.start} ~ ${seg.end}</div>
                    <div class="text">${(seg.text||'').replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]))}</div>
                    <div class="seg-images"></div>
                `;
                pane.appendChild(div);
                segDivs.push(div);
                refreshSnippet(segIdx);
                if(segIdx===0) setCurrentSegment(0);
                segIdx++;
                // schedule next
                requestAnimationFrame(renderNextSegment);
            }
            function refreshSnippet(idx){
                const wrap = segDivs[idx]?.querySelector('.seg-images');
                if(!wrap) return;
                wrap.innerHTML='';
                const arr = selections[idx] ?? [];
                arr.forEach(file=>{
                    const img = document.createElement('img');
                    img.src='/static/'+file;
                    img.alt=file;
                    wrap.appendChild(img);
                });
            }

            // track preview highlight with selection to set segment
            const observer = new IntersectionObserver(entries=>{
                entries.forEach(e=>{
                    if(e.isIntersecting){
                        const i = segDivs.indexOf(e.target);
                        if(i>=0) setCurrentSegment(i);
                    }
                })
            },{root:document.getElementById('infoPane'),threshold:0.1});
            const watchSegs = setInterval(()=>{
                if(segDivs.length===segments.length){
                    clearInterval(watchSegs);
                    segDivs.forEach(d=>observer.observe(d));
                }
            },500);

            loadSegments();

            // --- export via backend (Cmd + Enter) ---
            const overlay = document.getElementById('exportModalOverlay');
            const btnCancel = document.getElementById('exportCancel');
            const btnConfirm = document.getElementById('exportConfirm');

            function openExportModal(){ overlay.style.display='flex'; }
            function closeExportModal(){ overlay.style.display='none'; }

            btnCancel?.addEventListener('click', closeExportModal);
            btnConfirm?.addEventListener('click', async () => {
              const payload = { selections: {} };
              Object.keys(selections).forEach(k => { payload.selections[String(k)] = selections[k]; });
              const res = await fetch('/export', {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify(payload)
              });
              if(res.ok){
                const data = await res.json();
                showToast('已儲存: ' + data.path);
              } else {
                alert('匯出失敗: ' + await res.text());
              }
              closeExportModal();
            });

            window.addEventListener('keydown', ev => {
              if(ev.key === 'Enter' && ev.metaKey){
                ev.preventDefault();
                openExportModal();
              }
            });
            </script>
        <!-- Export confirmation modal -->
        <div id="exportModalOverlay">
          <div id="exportModal">
            <h3>確認輸出 Markdown？</h3>
            <p>將把目前所有段落文字與選擇的圖片儲存到後端。</p>
            <div id="exportModalActions">
              <button id="exportCancel">取消</button>
              <button id="exportConfirm">確認</button>
            </div>
          </div>
        </div>
        </body>
    </html>
